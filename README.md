# S.O.L.I.D Principles Study with Kotlin

This application serves as a practical study and implementation of the SOLID principles, designed to demonstrate the key concepts of object-oriented design and software architecture using Kotlin.

The SOLID principles are a set of guidelines that, when applied correctly, help in building maintainable, scalable, and robust applications. The goal of this project is to explore these principles in depth and show how they can be effectively used in Kotlin to improve code quality and design.

The application was developed for LMSRtech, an organization focused on software excellence. Each principle is carefully demonstrated through clean, simple Kotlin code examples, offering insights into how these principles can be applied in real-world scenarios.

Confluence with the documentation: https://lmsr.atlassian.net/wiki/x/UAIB

# S.O.L.I.D Principles in Kotlin

* **Single Responsibility Principle (SRP)** – A class should have only one reason to change, meaning each class should handle a single responsibility in your Kotlin code.

* **Open/Closed Principle (OCP)** – Software entities, such as classes or functions, should be open for extension but closed for modification. In Kotlin, this can be achieved using abstract classes or interfaces.

* **Liskov Substitution Principle (LSP)** – Derived classes in Kotlin should be interchangeable with their base classes without altering the expected behavior of the application.

* **Interface Segregation Principle (ISP)** – No client should be forced to implement interfaces it doesn't use. In Kotlin, prefer smaller, specific interfaces over large, general ones, allowing for more flexible design.

* **Dependency Inversion Principle (DIP)** – High-level modules should not depend on low-level modules in Kotlin. Instead, both should depend on abstractions like interfaces or abstract classes, which decouple code and allow for easier maintenance and testing.
